---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.14.1
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```python
import logging
import numpy as np
import pandas as pd
import networkx as nx
import seaborn as sns
from esneft_tools.utils import setVerbosity
from esneft_tools import download, process, visualise

setVerbosity(logging.INFO)
```

```python
# Instantiate data download class.
getData = download.getData(cache='./.data-cache')

# Retrieve all data as dictionary (recommended)
data = getData.fromHost('all')
```

```python
GPsummary = process.getGPsummary(**data, iod_cols='IMD')
LSOAsummary = process.getLSOAsummary(**data, iod_cols='IMD')
```

```python
DCdata = pd.read_pickle('DC-summary.pkl')
```

```python
# Get Node associated with patient postcode
DCdata = (pd.merge(
    DCdata, data['postcodeLSOA'][['LSOA11CD', 'Node']], 
    left_on='Patient_Postcode', right_index=True, how='left')
    .rename({'Node': 'Patient_Node'}, axis=1))
```

```python
# Get GP postcode associated with GP practice
DCdata = (pd.merge(
    DCdata, data['gpPractice'][['PCDS']],
    left_on='Registered.GP.Practice.Code', right_index=True, how='left')
    .rename({'PCDS': 'GP_Postcode'}, axis=1))

# Get Node associated with GP postcode
DCdata = (pd.merge(
    DCdata, data['postcodeLSOA'][['Node']], 
    left_on='GP_Postcode', right_index=True, how='left')
    .rename({'Node': 'GP_Node'}, axis=1))
```

```python
# Get IMD statistics associated with patient LSOA
DCdata = pd.merge(
    DCdata, LSOAsummary[['IMD', 'IMD (q5)']], 
    left_on='LSOA11CD', right_index=True, how='left')
```

```python
def computePath(x, osm, ref=None):
    if ref is None:
        ref = x['GP_Node']
    try:
        return nx.shortest_path_length(
            osm, x['Patient_Node'], ref, 
            weight='length', method='dijkstra')
    except:
        return -1
```

```python
ipswichHospital = data['postcodeLSOA'].loc[data['postcodeLSOA'].index == 'IP4 5PD', 'Node'][0]

# Compute distance between patient postcode and ipswich hosptial
DCdata.loc[DCdata['Patient_Node'].notna(), 'patient2site'] = (
     DCdata.loc[DCdata['Patient_Node'].notna()].apply(
         computePath, args=(data['esneftOSM'], ipswichHospital), axis=1)
)
DCdata.to_pickle('.DC-data.checkpoint1.pkl')
```

```python
# Compute distance between patient postcode and gp postcode
valid = (DCdata['Patient_Node'].notna() & DCdata['GP_Node'].notna())
DCdata.loc[valid, 'patient2GP'] = (
     DCdata.loc[valid].apply(
         computePath, args=(data['esneftOSM'],), axis=1)
)
DCdata.to_pickle('.DC-data.checkpoint2.pkl')
```

```python
GPreg = data['gpRegistration']
```

```python
dc_codes = set(DCdata['Registered.GP.Practice.Code'])
reg_codes = set(GPreg['OrganisationCode'])
missing = dc_codes ^ reg_codes

DCdata['validGP'] = ~DCdata['Registered.GP.Practice.Code'].isin(missing)
print(f'Identified {len(DCdata) - DCdata["validGP"].sum()} records with no valid GP.')
```

```python
GPreg = pd.merge(
    GPreg, LSOAsummary[['IMD', 'IMD (q5)', 'DM-prevalance']], 
    left_on='LSOA11CD', right_index=True, how='left')
```

```python
ageBins = [0, 3, 6, 14, 19, 34, 49, 65, 79, np.inf]
populationLSOA = data['populationLSOA']
populationLSOA = populationLSOA.loc[populationLSOA['LSOA11CD'].isin(DCdata['LSOA11CD'].unique())].copy()
populationLSOA['Age_group'] = pd.cut(populationLSOA['Age'].astype(float) + 0.001, bins=ageBins)
populationLSOA = pd.merge(
    populationLSOA, LSOAsummary[['IMD', 'IMD (q5)']], 
    left_on='LSOA11CD', right_index=True, how='left')
```

```python
LSOAsummary = pd.merge(
    LSOAsummary,
    DCdata.groupby('LSOA11CD').size().rename('DC-count'),
    left_index=True, right_index=True, how='left')
LSOAsummary['DC-count'] = LSOAsummary['DC-count'].fillna(0)
```

```python
populationLSOA.to_pickle('population-filtered.pkl')
GPreg.to_pickle('gp-reg-filtered.pkl')
DCdata.to_pickle('dc-filtered.pkl')
LSOAsummary.to_pickle('lsoa-summary.pkl')
GPsummary.to_pickle('gp-summary.pkl')
```

```python
visualise.choroplethLSOA(LSOAsummary, data['geoLSOA'], colour='DM-prevalance', cmap='viridis')
```

```python
visualise.choroplethLSOA(LSOAsummary, data['geoLSOA'], colour='DC-count', cmap='greys')
```

```python
df = pd.read_pickle('gp-summary.pkl')
```

```python
from datetime import datetime
from cryptography.fernet import Fernet
from pandas.api.types import is_object_dtype
from pandas.api.types import is_datetime64_any_dtype as is_datetime
```

```python
def writeKey(path):
    key = Fernet.generate_key()
    with open(path, 'wb') as fh:
        fh.write(key)

        
def readKey(key):
    if key == cryptography.fernet.Fernet:
        return key
    with open(key, 'rb') as fh:
        key = fh.read()
    return Fernet(key)


def writeEncrypt(df, key, path=None):
    f = readKey(key)
    df = df.reset_index()
    cols = df.columns
    for col in cols:
        dtype = df[col].dtype
        if dtype == float:
            name = f'{col}-float'
        elif dtype == int:
            name = f'{col}-int'
        elif dtype == bool:
            name = f'{col}-bool'
        elif is_datetime(df[col]):
            name = f'{col}-dt'
        elif is_object_dtype(df[col]):
            name = f'{col}-object'
            df.loc[df[col].isna(), col] = ''
        else:
            print(f'Cannot encrypt column {col} with '
                  f'dtype {dtype}.', file=sys.stderr)
            continue
        if name.endswith('-dt'):
            df[name] = df[col].dt.strftime('%Y-%B-%d-%H-%M-%S')
        else:
            df[name] = df[col].astype(str)
        name_encrypt = f.encrypt(f'{name}-encrypted'.encode('utf-8'))
        df[name_encrypt] = df[name].apply(
            lambda x: f.encrypt(str(x).encode('utf-8')))
        df = df.drop([name, col], axis=1)
    if path is not None:
        df.to_parquet(path)
    return df


def readEncrypt(path, key):
    df = pd.read_parquet(path)
    encrypted_cols = df.columns
    for col_name_encrypt in encrypted_cols:
        col_name = f.decrypt(col_name_encrypt).decode('utf-8')
        if not col_name.endswith('-encrypted'):
            continue
        name = col_name.removesuffix('-encrypted')
        df[name] = df[col_name_encrypt].apply(
            lambda x: f.decrypt(x).decode('utf-8'))
        col, dtype = name.rsplit('-', 1)
        if dtype == 'dt':
            df[col] = df[name].apply(
                lambda x: pd.NaT if x == 'nan' else 
                datetime.strptime(x, '%Y-%B-%d-%H-%M-%S'))
        elif dtype == 'object':
            df[col] = df[name]
            df.loc[df[col] == '', col] = np.nan
        else:
            df[col] = df[name].astype(eval(dtype))
        df = df.drop([name, col_name_encrypt], axis=1)
    df = df.set_index(df.columns[0])
    return df
```

```python
keyPath = 'key.key'
writeKey(keyPath)
```

```python
df_encrypt = writeEncrypt(df, keyPath, path='encrypted.parquet')
```

```python
df_decrypt = readEncrypt('encrypted.parquet', keyPath)
```

```python
df_encrypt.head()
```

```python
df_decrypt.head()
```

```python

```
